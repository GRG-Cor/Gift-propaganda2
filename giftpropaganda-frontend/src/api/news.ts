import axios from 'axios';
import { NewsItem } from '../types';

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è API
const API_CONFIG = {
  LOCAL: 'http://localhost:8000/api/news',
  LOCAL_PROD: 'http://localhost:8001/api/news',
  PROD: 'https://gift-propaganda-cf8i.onrender.com/api/news',
  GITHUB_PAGES: 'local', // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π API –¥–ª—è GitHub Pages
  TIMEOUT: 10000,
  RETRY_ATTEMPTS: 3,
  RETRY_DELAY: 1000
};

// –°–æ—Å—Ç–æ—è–Ω–∏–µ API
let currentAPI = API_CONFIG.LOCAL;
let apiHealth = {
  local: false,
  prod: false
};

// –ö—ç—à –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
const cache = new Map<string, { data: any; timestamp: number }>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 –º–∏–Ω—É—Ç

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫—ç—à–∞
const getFromCache = (key: string) => {
  const cached = cache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }
  return null;
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ –∫—ç—à
const setCache = (key: string, data: any) => {
  cache.set(key, { data, timestamp: Date.now() });
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–¥–µ—Ä–∂–∫–∏
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è API
const checkAPIHealth = async (url: string): Promise<boolean> => {
  try {
    const response = await axios.get(url + '?limit=1', {
      timeout: 3000,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    });
    return response.status === 200;
  } catch {
    return false;
  }
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ API
const initializeAPI = async () => {
  if (typeof window !== 'undefined' && window.location.hostname === 'localhost') {
    try {
      const localHealth = await checkAPIHealth(API_CONFIG.LOCAL);
      apiHealth.local = localHealth;
      if (localHealth) {
        currentAPI = API_CONFIG.LOCAL;
      } else {
        const prodHealth = await checkAPIHealth(API_CONFIG.PROD);
        apiHealth.prod = prodHealth;
        if (prodHealth) {
          currentAPI = API_CONFIG.PROD;
        } else {
          currentAPI = API_CONFIG.PROD; // fallback —Ç–æ–ª—å–∫–æ –Ω–∞ –ø—Ä–æ–¥–∞–∫—à–Ω
        }
      }
    } catch (error: any) {
      currentAPI = API_CONFIG.PROD;
    }
  } else {
    // –î–ª—è –ª—é–±–æ–≥–æ –Ω–µ-–ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ö–æ—Å—Ç–∞ –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ HTTPS-–ø—Ä–æ–¥–∞–∫—à–Ω API
    currentAPI = API_CONFIG.PROD;
    apiHealth.prod = true;
    apiHealth.local = false;
  }
};
// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞ —Å retry
const executeWithRetry = async <T>(
  requestFn: () => Promise<T>,
  retries: number = API_CONFIG.RETRY_ATTEMPTS
): Promise<T> => {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await requestFn();
    } catch (error: any) {
      if (attempt === retries) {
        throw error;
      }
      
      if (currentAPI === API_CONFIG.LOCAL && apiHealth.prod) {
        currentAPI = API_CONFIG.PROD;
      } else if (currentAPI === API_CONFIG.PROD && apiHealth.local) {
        currentAPI = API_CONFIG.LOCAL;
      }
      
      await delay(API_CONFIG.RETRY_DELAY * attempt);
    }
  }
  
  throw new Error('–í—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –Ω–µ —É–¥–∞–ª–∏—Å—å');
};

export interface NewsResponse {
  status?: string;
  data: NewsItem[];
  message?: string;
  total?: number;
  page?: number;
  limit?: number;
  pages?: number;
}

export const fetchNews = async (
  category?: string, 
  page: number = 1, 
  limit: number = 20,
  useCache: boolean = true
): Promise<NewsResponse> => {
  try {
    console.log('üîç –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–æ–≤–æ—Å—Ç–∏:', { category, page, limit });
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏–º—Å—è –ª–∏ –º—ã –Ω–∞ GitHub Pages
    if (window.location.hostname.includes('github.io')) {
      console.log('üåê –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π API –¥–ª—è GitHub Pages');
      
      if (window.API) {
        const result = await window.API.getNews(category, page, limit);
        console.log('‚úÖ –ü–æ–ª—É—á–µ–Ω—ã –Ω–æ–≤–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ –ª–æ–∫–∞–ª—å–Ω—ã–π API:', result.data?.length || 0, '—à—Ç.');
        return result;
      }
    }
    
    console.log('üîç –¢–µ–∫—É—â–∏–π API:', currentAPI);
    
    const cacheKey = `news_${category || 'all'}_${page}_${limit}`;
    
    if (useCache) {
      const cachedData = getFromCache(cacheKey);
      if (cachedData) {
        console.log('üì¶ –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –Ω–æ–≤–æ—Å—Ç–∏');
        return cachedData;
      }
    }

    const params = new URLSearchParams();
    if (category && category !== 'all') params.append('category', category);
    params.append('limit', limit.toString());
    params.append('offset', ((page - 1) * limit).toString());

    const url = `${currentAPI}?${params.toString()}`;
    console.log('üîç URL –∑–∞–ø—Ä–æ—Å–∞ –Ω–æ–≤–æ—Å—Ç–µ–π:', url);

    const response = await executeWithRetry(async () => {
      return await axios.get<NewsResponse>(url, {
        headers: {
          'ngrok-skip-browser-warning': 'true',
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        },
        timeout: API_CONFIG.TIMEOUT
      });
    });

    console.log('‚úÖ –ü–æ–ª—É—á–µ–Ω—ã –Ω–æ–≤–æ—Å—Ç–∏:', response.data.data?.length || 0, '—à—Ç.');
    console.log('‚úÖ –ü–µ—Ä–≤–∞—è –Ω–æ–≤–æ—Å—Ç—å:', response.data.data?.[0]?.title);
    
    if (useCache) {
      setCache(cacheKey, response.data);
    }
    
    return response.data;
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –Ω–æ–≤–æ—Å—Ç–µ–π:', error.message);
    console.error('‚ùå –¢–µ–∫—É—â–∏–π API:', currentAPI);
    
    const fallbackData: NewsResponse = {
      data: [
        {
          id: 1,
          title: "üì∞ –ù–æ–≤–æ—Å—Ç–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã",
          content: "–ú—ã —Ä–∞–±–æ—Ç–∞–µ–º –Ω–∞–¥ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ–º —Å–µ—Ä–≤–∏—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
          content_html: "<p>–ú—ã —Ä–∞–±–æ—Ç–∞–µ–º –Ω–∞–¥ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ–º —Å–µ—Ä–≤–∏—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.</p>",
          link: "#",
          publish_date: new Date().toISOString(),
          category: "general",
          media: []
        }
      ],
      total: 1,
      page: 1,
      pages: 1
    };

    return fallbackData;
  }
};

export const fetchNewsById = async (id: number): Promise<NewsItem> => {
  try {
    const cacheKey = `news_item_${id}`;
    const cachedData = getFromCache(cacheKey);
    if (cachedData) {
      console.log('üì¶ –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–æ–≤–æ—Å—Ç–∏', id);
      return cachedData;
    }

    const url = `${currentAPI}/${id}`;
    console.log('üîç –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –Ω–æ–≤–æ—Å—Ç—å:', url);
    
    const response = await executeWithRetry(async () => {
      return await axios.get<NewsItem>(url, {
        headers: {
          'ngrok-skip-browser-warning': 'true',
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        timeout: API_CONFIG.TIMEOUT
      });

    });

    console.log('‚úÖ –ü–æ–ª—É—á–µ–Ω–∞ –Ω–æ–≤–æ—Å—Ç—å:', response.data.id, 'content_html –¥–ª–∏–Ω–∞:', response.data.content_html?.length || 0);
    setCache(cacheKey, response.data);
    return response.data;
  } catch (error: any) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–æ–≤–æ—Å—Ç–∏:', error.message);
    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–æ–≤–æ—Å—Ç—å');
  }
};

export const fetchCategories = async (): Promise<string[]> => {
  try {
    const cacheKey = 'categories';
    const cachedData = getFromCache(cacheKey);
    if (cachedData) {
      return cachedData;
    }

    const response = await executeWithRetry(async () => {
      return await axios.get<{status: string, data: string[]}>(`${currentAPI}categories/`, {
        headers: {
          'ngrok-skip-browser-warning': 'true',
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        timeout: API_CONFIG.TIMEOUT
      });
    });

    const categories = response.data.data || ['gifts', 'crypto', 'tech', 'community', 'gaming'];
    setCache(cacheKey, categories);
    return categories;
  } catch (error) {
    return ['gifts', 'crypto', 'tech', 'community', 'gaming'];
  }
};

export const clearCache = () => {
  cache.clear();
};

export const getAPIStatus = () => ({
  currentAPI,
  apiHealth,
  cacheSize: cache.size
});

if (typeof window !== 'undefined') {
  initializeAPI();
}
